clear all
close all
clc

%% 
run("merge_data.m")

%% 

n = 3 + 15 * 2;         % number of state
m = 2;                  % number of control input

%% calculate the jacobian of C matrix
syms Px Py theta m1x  m1y  m2x  m2y  m3x  m3y  m4x  m4y  m5x  m5y...
                 m6x  m6y  m7x  m7y  m8x  m8y  m9x  m9y m10x m10y...
                m11x m11y m12x m12y m13x m13y m14x m14y m15x m15y real
%% 

Pt = [Px;Py];
Rotation_Matrix = [cos(theta) sin(theta); -sin(theta) cos(theta)];
g_t = [norm([m1x; m1y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m1x;m1y]-[Px;Py]), Rotation_Matrix(1,:)*([m1x;m1y]-[Px;Py]));...
       norm([m2x; m2y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m2x;m2y]-[Px;Py]), Rotation_Matrix(1,:)*([m2x;m2y]-[Px;Py]));...
       norm([m3x; m3y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m3x;m3y]-[Px;Py]), Rotation_Matrix(1,:)*([m3x;m3y]-[Px;Py]));...
       norm([m4x; m4y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m4x;m4y]-[Px;Py]), Rotation_Matrix(1,:)*([m4x;m4y]-[Px;Py]));...
       norm([m5x; m5y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m5x;m5y]-[Px;Py]), Rotation_Matrix(1,:)*([m5x;m5y]-[Px;Py]));...
       norm([m6x; m6y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m6x;m6y]-[Px;Py]), Rotation_Matrix(1,:)*([m6x;m6y]-[Px;Py]));...
       norm([m7x; m7y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m7x;m7y]-[Px;Py]), Rotation_Matrix(1,:)*([m7x;m7y]-[Px;Py]));...
       norm([m8x; m8y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m8x;m8y]-[Px;Py]), Rotation_Matrix(1,:)*([m8x;m8y]-[Px;Py]));...
       norm([m9x; m9y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m9x;m9y]-[Px;Py]), Rotation_Matrix(1,:)*([m9x;m9y]-[Px;Py]));...
       norm([m10x; m10y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m10x;m10y]-[Px;Py]), Rotation_Matrix(1,:)*([m10x;m10y]-[Px;Py]));...
       norm([m11x; m11y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m11x;m11y]-[Px;Py]), Rotation_Matrix(1,:)*([m11x;m11y]-[Px;Py]));...
       norm([m12x; m12y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m12x;m12y]-[Px;Py]), Rotation_Matrix(1,:)*([m12x;m12y]-[Px;Py]));...
       norm([m13x; m13y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m13x;m13y]-[Px;Py]), Rotation_Matrix(1,:)*([m13x;m13y]-[Px;Py]));...
       norm([m14x; m14y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m14x;m14y]-[Px;Py]), Rotation_Matrix(1,:)*([m14x;m14y]-[Px;Py]));...
       norm([m15x; m15y] - Pt);...
       atan2(Rotation_Matrix(2,:)*([m15x;m15y]-[Px;Py]), Rotation_Matrix(1,:)*([m15x;m15y]-[Px;Py]))];

x_t = [Pt; theta;  m1x;  m1y;  m2x;  m2y;  m3x;  m3y;  m4x;  m4y;  m5x;  m5y;...
                   m6x;  m6y;  m7x;  m7y;  m8x;  m8y;  m9x;  m9y; m10x; m10y;...
                  m11x; m11y; m12x; m12y; m13x; m13y; m14x; m14y; m15x; m15y];
C_t = jacobian(g_t, x_t);

%% implement EKF
% simulate the first 50000 rows (approx. 725 sec)

simTime = 50000;
initial_pose = Robot1_Groundtruth(350, 2:4);
initial_guess_landmarks = zeros(1,30);

mu_EKF = NaN(simTime,n);  
mu_EKF(1,:) = [initial_pose initial_guess_landmarks];       

sigma_EKF = NaN(n*simTime,n);
sigma_EKF(1:n, 1:n) = 7*eye(n);         % initialize sigma_0|0 as 7I

% observable = zeros(simTime-1,1);
% controllable = zeros(simTime-1,1);

i = 1;      % simulation starts at the first row(time step) of control input 

flag_feature = 6:20;

while i < simTime
    
    dt = round( Robot(i+1,1) - Robot(i,1), 3 );         % rounded
    j = i + 1;

    % import measurement data, if there is any
    if Robot(j,2) == 1
        y = [];
        while Robot(j+1,2) == 1 
            j = j + 1;
        end
        for k = i+1:j
            if ismember(Robot(k,3), flag_feature)
                y = [y; Robot(k,3:5)];
            end
        end
    end

    % PREDICTION
    mu_pred = [mu_EKF(i,1)+dt*Robot(i,3)*cos(mu_EKF(i,3)) ...
               mu_EKF(i,2)+dt*Robot(i,3)*sin(mu_EKF(i,3)) ...
               mu_EKF(i,3)+dt*Robot(i,4) ...
               mu_EKF(i,4) ...
               mu_EKF(i,5) ...
               mu_EKF(i,6) ...
               mu_EKF(i,7) ...
               mu_EKF(i,8) ...
               mu_EKF(i,9) ...
               mu_EKF(i,10) ...
               mu_EKF(i,11) ...
               mu_EKF(i,12) ...
               mu_EKF(i,13) ...
               mu_EKF(i,14) ...
               mu_EKF(i,15) ...
               mu_EKF(i,16) ...
               mu_EKF(i,17) ...
               mu_EKF(i,18) ...
               mu_EKF(i,19) ...
               mu_EKF(i,20) ...
               mu_EKF(i,21) ...
               mu_EKF(i,22) ...
               mu_EKF(i,23) ...
               mu_EKF(i,24) ...
               mu_EKF(i,25) ...
               mu_EKF(i,26) ...
               mu_EKF(i,27) ...
               mu_EKF(i,28) ...
               mu_EKF(i,29) ...
               mu_EKF(i,30) ...
               mu_EKF(i,31) ...
               mu_EKF(i,32) ...
               mu_EKF(i,33)];
    
    A_pose_part = [1 0 -dt*Robot(i,3)*sin(mu_EKF(i,3));...
                   0 1  dt*Robot(i,3)*cos(mu_EKF(i,3));...
                   0 0                 1];
    A_landmark_part = eye(30);

    A = [A_pose_part  zeros(3,30);...
         zeros(30,3)  A_landmark_part];

    Q = [Q1 zeros(3,30); zeros(30,3) 0.01*eye(30)]; 
    % NOT SURE if I can do this. 
    % Basically saying that there is cross covariance between each pose
    % state, but the distribution of each landmark position is independent
    % with all other states.
    % If we cannot do this operation, it probably means that we might not
    % be able to recover the original map. 

    sigma_pred = A * sigma_EKF(n*i-n+1:n*i,:) * transpose(A) + Q;

    % UPDATE

%     Px = mu_pred(1); Py = mu_pred(2);
%     m1x = mu_pred(4); m1y = mu_pred(5);
%     m2x = mu_pred(6); m2y = mu_pred(7);
%     m3x = mu_pred(8); m3y = mu_pred(9);
%     m4x = mu_pred(10); m4y = mu_pred(11);

    % The dimension of C would change over time 
    C = [];
    K = sigma_pred * transpose(C) / (C*sigma_pred*transpose(C) + R);

    g = [norm([m1x; m1y] - [Px; Py]);...
         norm([m2x; m2y] - [Px; Py]);...
         norm([m3x; m3y] - [Px; Py]);...
         norm([m4x; m4y] - [Px; Py]);...
         ([m1x; m1y] - [Px; Py])/norm([m1x; m1y] - [Px; Py]);...
         ([m2x; m2y] - [Px; Py])/norm([m2x; m2y] - [Px; Py]);...
         ([m3x; m3y] - [Px; Py])/norm([m3x; m3y] - [Px; Py]);...
         ([m4x; m4y] - [Px; Py])/norm([m4x; m4y] - [Px; Py])];

    mu_EKF(:,i+1) = mu_pred + K * (y(:,i) - g);
    sigma_EKF(:,n*i+1:n*i+n) = sigma_pred - K * C * sigma_pred;

%     % check observability matrix
%     observability_matrix = [C; C*A; C*A*A];
%     if rank(observability_matrix) == n
%         observable(i) = 1;
%     end
% 
%     % check controllability matrix
%     controllability_matrix = [chol(Q) A*chol(Q) A*A*chol(Q)];
%     if rank(controllability_matrix) == n
%         controllable(i) = 1;
%     end

    i = j;
end 

mu_EKF = rmmissing(mu_EKF, 1);
sigma_EKF = rmmissing(sigma_EKF, 1);
